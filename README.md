# SVK
Простой клиент для работы с VK API написанный из учебного интереса и от скуки. Не рекомендую всерьез это использовать, может быть много недоработок.
# Что требуется из библиотек для работы?
- Requests
- Cherrypy (для callback-сервера)
# Начало работы
> Если вам проще изучить код, то можете изучить скрипт example.py
- Инициализация Longpoll/Callback клиента
```python
from client import Longpoll, Callback

app = Longpoll(
	access_token='YOUR_TOKEN', # токен группы
	# также есть прочие параметры, о них речь ниже
)

callback_app = Callback(
	access_token='YOUR_TOKEN', # токен
	confirmation='CONFIRM_CODE', # ключ подтверждения
	secret='SECRET_KEY' # секретный ключ
)

# запуск Longpoll'а
app.poll(
	multithreading=True # настройка многопоточности
	threads_amount=5 # кол-во потоков
)

# запуск callback'а, если вы запускаете напрямую
callback_app.launch_server(
	ip='127.0.0.1',
	port=80
)
# получение сервера, если вы хотите запустить сервер иначе (например через UWSGI)
callback_server = callback_app.get_sever()
```
## Параметры клиента (и Longpoll, и Callback)
| Параметр | Описание |
|-----:|:----|
|access_token| Токен группы, строка, **единственный обязательный параметр** |
|api_timeout| Максимальное время ожидания ответа от API, число |
|api_version| Версия API, строка |
|handle_callback| Обрабатывать по дефолту сообщения типа message_event (из callback-кнопок), boolean |
|handle_payload| Обрабатывать по дефолту команды из payload'а (обычные кнопки, н-р), boolean |
|predict_commands| "Угадывать" ли команды, об этом пойдет речь дальше, boolean |
|handle_bots| Обрабатывать ли сообщения ботов (групп), boolean |
|message_error_handler | Функция или callable объект, которй будет вызван при получении ошибки во время обработки сообщения (*далее об этом есть раздел*) |
|other_error_handler | Фунция или callable объект, который будет вызван при получении ошибки во время обработки события (*далее об этом тоже есть раздел*) |
## Параметры только Longpoll клиента
| Параметр | Описание |
|-----:|:-----|
|wait| Время ожидания от Longpoll'а ВКонтакте|
## Параметры только Callback клиента
| Параметр | Описание |
|------:|:-----|
|secret| Секретный ключ вашего сервера, если его нет, то не трогайте параметр |
|confirmation| Ключ подтверждения, если хотите получить его через API, оставьте пустым |
# Как делать запросы к API?
- Получить объект API-клиента при помощи метода get_api()
```python
api = app.get_api()
print(api.groups.getById(group_id=1))
```
- Обращаться к переменной клиента api
```python
print(app.api.users.get(user_ids=[1])[0])
```
# Как обработать соообщение?
## Обработка сообщения по регулярному выражению/командам
Для обработки определнных шаблонов сообщения используются обратчики функций, объявляемые через декоратор
```python
from client import Longpoll

app = Longpoll(...)

# обработка по команде
@app.message_handler(commands=['hello'])
def command_handle(message):
	app.reply(message, 'Hi!') # функция ответа на сообщение

# обработка по регулярному выражению
@app.message_handler(regex=r'^regex ([0-9]{1,}) (.{1,})')
def regex_handle(message, matches):
	app.reply(message, 'Сработало регулярное выражение')
```
> Важное примечание: регулярные выражения по дефолту регистронезависимы, а при ненахождении нужной команды применяется поиск по совпадениям при помощи формулы расстояния Дамерау-Левенштейна. "Угадывание" команды помогает в случае опечаток, но может и навредить. Полностью отключить его можно параметром predict_commands

> Важное примечание 2: если срабатывает один из обработчиков, другие обработчики не оповещаются. Об обработке всех сообщений речь пойдет далее.
## Разбираем механику работы
При получении события, бот обходит все обработчики и если фильтры обработчика удовлетворяют, то бот вызывает это функцию с параметром события (сообщения) и в случае с командой по регулярному выражению с массивом/строкой совпадения групп. *О структуре параметра сообщения/события речь пойдет дальше*
## Параметры обработчиков сообщений (через app.message_handler)
| Параметр | Описание |
|---------:|:--------|
|commands| Массив строк-слов, с которых сообщение должно начаться. **Если указано и регулярное выражение, команды имеют больший приоритет, две проверки за раз невозможны** |
|prefix| **Для команд**. Префикс, который добавится ко всем командам, строка. Необязателен. |
|predict| **Для команд**. Нужно ли конкретному обработчику "угадывать" команды. Необязателен. |
|regex| Регулярное выражение в виде строки. Регистронезависимо по дефолту. |
|message_type| Массив типов сообщений для обработки, список типов: text (простое текстовое сообщение), payload (сообщение из payload'а), callback (сообщение из callback-кнопок). При неуказании используются параметры из класса клиента. |
| &#95;filter | Функция или callable объект, которому передается объект сообщения. Должен вернуть True или False. Необязателен. |
## Обработка всех сообщений
Чтобы обработчик начал обрабатывать все сообщения, не указывайте regex или commands. В таком случае все обработчики всех сообщений будут вызваны.
# Как обрабатывать событие?
Для обработки события используйте декоратор **app.custom_handler**. Имеет единственный параметр - тип события с https://vk.com/dev/groups_events
```python
@app.custom_handler('message_deny')
def message_deny_handler(event):
	print(event.user_id) # выводит айди пользователя, запретившего написание сообщений в ЛС
```
# Структура событий и сообщений
Различные обработчики передают функции либо объект события, либо объект сообщения. Помимо общих параметров, вы можете напрямую обращаться к аттрибутам событий.
```python
@app.message_handler()
def print_from_id(message):
	print(message.from_id)

@app.custom_handler('like_add')
def print_liker_id(event):
	print(event.liker_id)
```
## Общие параметры объекта события
|Параметр| Описание|
|------:|:-----|
|event| Информация о событии (включая тип и айди группы) |
|type| Тип события |
|object| Объект события (https://vk.com/dev/groups_events)|
|Ситуативные параметры| Например, можно обращаться к полям в object'е события |
## Общие параметры сообщения
|Параметр|Описание|
|-----:|:------|
|Все параметры из объекта события||
|from_payload| Поймана ли полезная нагрузка. Основной шаблон - {'command': 'YOUR_TEXT'}|
|callback| Получено ли это сообщение по callback-ивенту|
|chat_id| Рассчитанный айди чата. Если сообщение из личных сообщений, то равен нулю |
|from_chat| Boolean-переменная, показывает из беседы ли сообщение|
|message_words| Слова сообщения |
|command| Первое слово сообщения, используется для проверки по командам|
|Стандартные параметры сообщения, по типу text, attachments и др.||

**Важное примечание: параметр message.text редактируется ботом (в случае работы через пуш группы, payload и.т.д). Если вы хотите работать с "сырым" текстом, получите его через message.object**
# А как обработать приглашения/исключения в беседе и прочее?
Для киков/приглашений/входов по ссылке есть готовые обработчики.
```python
@app.kick_handler()
def kick_handle(message):
	app.reply(message, f'id {message.action["member_id"]} был исключен/вышел из беседы.')

@app.invite_handler()
def invite_handle(message):
	app.reply(message, f'id {message.action["member_id"]} присоединился к беседе.')
```
Для прочих action-событий (https://vk.com/dev/objects/message) используйте app.action_handler(*тип события*)
```python
@app.action_handler('chat_title_update')
def chat_name_handle(message):
	app.reply(message, 'Название беседы изменено!')
```
# Как можно ответить на событие?
- Самостоятельно отправить сообщение через API или метод send_message
```python
@app.message_handler()
def test(message):
	app.send_message(peer_id=message.peer_id, text='Test')
```
- Воспользоваться методом app.reply
**Примечание: бот может самостоятельно разбить текст на куски в случае с этим методом и методом выше**
```python
@app.message_handler(commands=['among'])
def test2(message):
	app.reply(message, 'us')
```
**app.reply обязательно требует параметр message и текст для отправки. Остальное можно отправить через kwargs, сообщения без текста лучше отправлять через другие методы.**
- Для callback-сообщений есть варианты, описанные в API - snackbar, открытие ссылки, открытие приложения, редактирование сообщения
```python
app.show_snackbar(message, 'Это снэкбар')
app.open_link(message, 'https://vk.com/durov')
app.open_app(message, app_id=0, app_hash='', owner_id=1)
app.edit_message(message, 'Я отредачил сообщение!')
```
# А как загружать файлы?
Пока реализована только загрузка фото при помощи методов upload_photos и upload_photo
Функция upload_photo возвращает готовый код вложения, upload_photos массив кодов.
## Параметры функции upload_photo
|Параметр|Описание|
|--------:|:-----|
|path|Путь к фото (относительный). Пример: '1.jpg' (файл должен быть в одной папке с файлом бота)|
|abspath| Путь к фото (абсолютный)|
|delete_after| Удалить ли фото после загрузки в ВК.|
## Параметры функции upload_photos
|Параметр|Описание|
|-------:|:-------|
|path_list| Список **относительных путей** к фото.|
|delete_after| Удалить ли фото после загрузки в ВК.|
# Генерация клавиатуры
Для генерации клавиатуры из файла keyboard импортируйте класс Keyboard.
```python
from keyboard import Keyboard

@app.message_handler(commands=['ktest'])
def show_keyboard(message):
	keyboard = Keyboard(inline=True)
	keyboard.add_text_button(label='Нажми на меня!')
	app.reply(message, 'Вот ваша клавиатура!', keyboard=keyboard())

```
## Параметры создания клавиатуры
|Параметр|Описание|
|-------:|:-------|
|one_time|Уничтожится ли клавиатура после нажатия, boolean|
|inline|Инлайн-клавиатура или обычная, boolean|
|row_length_limit|Собственный ограничитель количества кнопок в ряду. Необязателен|
## Методы клавиатуры
|Метод|Параметры|Описание|
|-----:|:---:|:------|
|add_line| - | Добавить новый ряд кнопок (пустой)|
|add_text_button| label - текст на кнопке (строка), color - цвет кнопки (строка, по документации ВК), payload - полезная нагрузка (строка, необязателен), callback - callback-кнопка или нет (boolean), clear_payload - полезная нагрузка собственной структуры (словарь)| Создает обычную кнопку или callback-кнопку. |
|add_link_button| label - текст на кнопке (строка), url - ссылка (строка) | Создает перенаправляющую кнопку |
|get_keyboard| - | Позволяет получить саму клавиатуру для отправки ВК. Можно также просто вызвать класс. |
# А можно ли как-то обработать ошибки?
Прикиньте - да. При инициализации клиента вы можете передать параметры message_error_handler, other_error_handler. Обычно это функции, которым будут переданы параметры сообщения/события и само исключение. Если обработчики не указаны, то исключение будет просто вызвано через raise
```python
from client import Longpoll

def error_handler(message, exception):
	print(f'Ой ошибка: {exception}')
 
app = Longpoll(
	access_token='TOKEN',
	message_error_handler=error_handler
)
```
